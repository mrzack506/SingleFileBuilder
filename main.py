import exceptions, os, binascii, ast

class ProjectBuilder:

    def __init__(self, project_path : str, entry_file : str) -> None:
        self.project_path = project_path
        self.entry_file = entry_file

        # Check if project exists on disk.
        if not os.path.isdir(self.project_path):
            raise exceptions.ProjectNotFoundError('Project could not be located on disk.')
        
        # Check if entry file exists on disk.
        if not os.path.isfile(f'{self.project_path}\\{self.entry_file}'):
            raise exceptions.FileNotFoundError('Entry file could not be located in the project.')
        
        # Custom importer / hex converter for entry file:
        self.importer = [
            'import warnings, binascii',
            'with warnings.catch_warnings():',
            '   warnings.filterwarnings("ignore", category=DeprecationWarning)',
            '   import imp',
            '',
            'def import_module(src, name):',
            '   module = imp.new_module(name)',
            '   module.__dict__.update(globals())',
            '   module.__dict__["__name__"] = name',
            '   exec(src, module.__dict__)',
            '   return module\n'
        ]

        # Get dependency files in project folder:
        self.project_deps = [f for f in os.listdir(self.project_path) if f != self.entry_file and f.endswith('.py')]
        
        # Data extracted from project:
        self.std_import_lines = []
        self.project_imports = []

        # Data generated by builder:
        self.dynamic_imports = []

        self.output_file_lines = []

        self.__extract_imports(f"{self.project_path}\\{self.entry_file}")
        for f in self.project_deps:
            self.__extract_imports(f"{self.project_path}\\{f}")
        
        # Remove duplicate imports:
        self.std_import_lines = list(dict.fromkeys(self.std_import_lines))

        # Add imports to output file:
        self.output_file_lines += self.std_import_lines

        self.output_file_lines.append('\n')

        # Add dynamic importer to output file:
        self.output_file_lines += self.importer

        self.output_file_lines.append('\n')

        # Loop through dependencies, and build the output file:
        for f in self.project_deps:
            self.output_file_lines.append(self.__file_to_dynamic_import(f"{self.project_path}\\{f}"))
            
            self.output_file_lines.append('\n')
        
        # Add entry file to output file:
        with open(f'{self.project_path}\\{self.entry_file}', 'r') as f_read:
            # Remove imports from file:
            f_lines = f_read.read().splitlines()
            f_lines = [l for l in f_lines if not l.startswith('import') and not l.startswith('from')]
        self.output_file_lines += f_lines

        print('\n'.join(self.output_file_lines))


    # Standard Import Extraction:
    def __extract_imports(self, file_path):
        with open(file_path, 'r') as f_read:
            f_lines = f_read.read().splitlines()
        
        # Extract all imports from file:
        import_lines = [l for l in f_lines if l.strip().startswith('import') or l.strip().startswith('from')]

        # Remove project imports from import lines:
        for line in import_lines:
            # Parse import line using AST
            for node in ast.iter_child_nodes(ast.parse(line)):
                # Check if node is a 'import %s' statement.
                if isinstance(node, ast.Import):
                    for n in node.names:
                        # Check if node.name is a project file
                        if n.name in [f.replace('.py', '') for f in self.project_deps]:
                            pass
                        # If node.name is a standard module:
                        else:
                            if n.asname == None:
                                self.std_import_lines.append(f'import {n.name}')
                            else:
                                self.std_import_lines.append(f'import {n.name} as {n.asname}')
                # Check if node is a 'from %s import %s' statement.
                if isinstance(node, ast.ImportFrom):
                    for n in node.names:
                        # Check if node.name is a project file
                        if n.name in [f.replace('.py', '') for f in self.project_deps]:
                            pass
                        # If node.name is a standard module:
                        else:
                            if n.asname == None:
                                self.std_import_lines.append(f'from {node.module} import {n.name}')
                            else:
                                self.std_import_lines.append(f'from {node.module} import {n.name} as {n.asname}')

    # Custom Import Conversion
    def __file_to_dynamic_import(self, file_path):
        if not os.path.isfile(file_path):
            raise exceptions.FileNotFoundError('Dependency file could not be found.')
        
        file_name = file_path.split('\\')[-1].replace('.py', '')
        with open(file_path, 'r') as f_read:
            # Remove imports from file:
            f_lines = f_read.read().splitlines()
            f_lines = [l for l in f_lines if not l.startswith('import') and not l.startswith('from')]
            f_data = "\n".join(f_lines)
            # Build import line from file:
            import_stmnt = f"{file_name} = import_module(binascii.unhexlify({binascii.hexlify(f_data.encode())}), '{file_name}')"
        
        return import_stmnt

builder = ProjectBuilder(r'C:\Users\KiwaN\Documents\Lithium Development\Recoil Script\Loader', 'main.py')